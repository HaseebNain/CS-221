
****************
* p2
* CompSci 221-001
* March 22
* Haseeb Nain
**************** 

PROJECT OVERVIEW:

This program will play the game of Boggle. The game is created by taking in a file of a grid of letters.
The program will then search for words created by the letters in the grid file. The program will be able
to complete its search of words using either stacks or queues, which is determined by the user.



INCLUDED FILES:

 * README - this file
 * grid.dat - this file contains a grid of letters.
 * BoggleBoard.java - This file creates a board
 * BoggleDice.java - Represents a set of Boggle dice. When more dice are needed than are present 
 	in the standard 16-dice set, BoggleDice uses multiple sets to maintain letter frequencies.
 * BoggleDictionary.java - This class the valid words that can be searched for by the boggle board.
 * BoggleGUI.java - This file will create a GUI of the boggle board and all the words found in that BoggleBoard 
 * BoggleSearch.java - This file will search a grid of letters for all available words, 
 	as determined by the BoggleDictionary.java class. This file takes in values from the command line,
 	which will determined the size of the grid to be searched, whether the use of stacks or queues will
 	be used to search, and whether to provide
 the results in the console, or in the form of a GUI.
 * ListPanel.java - This file creates a JPanel which will be used by the BoggleGUI.java class
 	and will contain all available words in the BoggleBoard
 *Storage.java - This file is a container which stores elements of type T in one of several possible
  underlying data structures. These data structures include stacks or queues.


BUILDING AND RUNNING:

 * This program must run from the command line: 
    -The first command line argument should be a positive integer specifying the grid size, N. The game grid will have dimensions NxN.
    -The second command line argument should be either -q (for using a queue) or -s (for using a stack).
    -If the third command line argument is -c, the program should run in console mode. If it is -g, the program should run in GUI mode.
    -The fourth argument should be the name of a file containing a set of letters to initialize the grid.
 * The program worked correctly on Windows and Onyx computers.
 * To run this program, you must run the program with BoggleSearch.java class
 

PROJECT DESIGN NOTES:

 * This program will receive a text file full of characters, which will then be searched by the program to find all the words generated by those letters
 	In order to create a GUI representation of the Boggle game, I created a different class, called BoggleGUI. This class works with a heavily modified version
 	of the ListPanel class which was provided as an example for this project assignment.
 	 
 


PROJECT DEVELOPMENT AND TESTING NOTES:

 * Try Catch statements were used in order to ensure that the correct arguments were passed to the program. Try/Catches were chosen to be used instead of simple
 if/else statements because if these arguments are incorrect then there could be fatal errors later during the runtime,
 * Words were found by placing all found combinations into the Storage class, these "words" were then analyzed and compared by the BoggleDictionary class. Once the
 word was found in the BoggleDictionary class it was removed from storage and placed into a HashSet. The use of the HashSet was to ensure that no 
 repetition occurred in the list words found.
 * The GUI was created with the help of two classes these classes are the BoggleGUI.java class and the ListPanel.java class. The ListPanel will take words from the
 	BoggleSearch and place them in a list and that will then be placed on the BoggleGUI
 * The Search Algorithm will use either a Stack method or a Queue method
 	The Searching will be explained below, using an example letter grid of:
 		T H
 		E N
 	--If the Stack Method is selected then the program will take each combination present in the grid, compare it to predetermined constraints(in this case
 	it will check to see if the word has a length greater then three and less then seventeen). This words will be stored into the StateStore storage class,
 	via the stacks .push() method. Those combinations will undergo the .pop() method, and those combinations will be pushed back onto the stack, only if that
 	that combinations matches a value found in the dictionary. Finally once the stack is full of legal words, it is pushed to the BoggleSearch, which in turn adds the
 	values to a String array and provides it for use by the rest of the program.
 	
 	--If the Queue Method is selected then the program will take each combination present in the grid, compare it to predetermined constraints(in this case
 	it will check to see if the word has a length greater then three and less then seventeen). This words will be stored into the StateStore storage class,
 	via the stacks .push() method. Those combinations will undergo the .pop() method, and those combinations will be pushed back onto the stack, only if that
 	that combinations matches a value found in the dictionary. Finally once the stack is full of legal words, it is pushed to the BoggleSearch, which in turn adds the
 	values to a String array and provides it for use by the rest of the program.
 
 * if a large grid is used, I tested with a grid of size 6, the computer will be unable to run the program. As too many comparisons are made and an the overhead limit is reached
 	the error traced by the StackTrace is as follows:
 		Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded 
 * In order to connect the ListPanel's ListListener to the BoggleGui's ActionListener the boggleGui
 	which implements the ActionListener is passed as reference to the ListPanel, by doing this
 	I was able to link the two actionListeners so that when a word is chosen in the list it is shown
 	in the BoggleGui's grid of buttons.
 * The word paths created by the BoggleGUI is done by a method created in BoggleSearch which accesses the private BoggleSearchStates getPath() method
 * In order to obtain more information, such as the information I used to get the Extra Credit, I created a static boolean in the BoggleSearch Class, that boolean when true will print more information to the console
 	by default I have set that boolean to false to ensure that the testProg doesn't account that extra information as new words.
 
EXTRA CREDIT:

 Collect data for the number of states evaluated and the maximum size of the state Storage using stacks and queues for different sized boards.
 Take your best shot at analyzing the runtime and memory usage of the search using stacks and queues. 
 
 ///////////
 Queue Data:
 ///////////
 For Grid
 	TAKA
	SCIR
	HEEW
	RUCX
 
 Letters: 16
 SearchStates Evaluated: 12029640
 Maximum Size of StateStore: 2645351
 
 For Grid
 	TAK
	SCI
	HEE

Letters: 9
SearchStates Evaluated: 10305
Maximum Size of StateStore: 2991

For Grid
	TA
	SC

Letters: 4
SearchStates Evaluated: 64
Maximum Size of StateStore: 23

For Grid
	T

Letters: 1
SearchStates Evaluated: 1
Maximum Size of StateStore: 0

////////////
Stack Data:
////////////
 For Grid
 	TAKA
	SCIR
	HEEW
	RUCX
 
 Letters: 16
 SearchStates Evaluated: 12029640
 Maximum Size of SearchState: 43
 
 For Grid
 	TAK
	SCI
	HEE

Letters: 9
SearchStates Evaluated: 10305
Maximum Size of SearchState: 20

For Grid
	TA
	SC

Letters: 4
SearchStates Evaluated: 64
Maximum Size of SearchState: 6


For Grid
	T

Letters: 1
SearchStates Evaluated: 1
Maximum Size of SearchState: 0

* I noticed that the size of the queue was always significantly larger when compared to the stack running the same grid. With a size of 16, the largest size for the queue ened up being greater than the
stack by a factor of  approximately 61520.
By comparing the amount of times the SearchStates are evaluated I realized that the amount of times the search evaluates the states is the same regardless of whether the values are stored via stack or queue.

 	
 	
 	
 	
 	
 	
 	
 	
 	
 	 